<?php

declare(strict_types=1);

namespace Fabiang\Doctrine\Migrations\Liquibase;

use Doctrine\Common\EventManager;
use Doctrine\DBAL\Connection;
use Doctrine\DBAL\Platforms\AbstractPlatform;
use Doctrine\DBAL\Schema\AbstractSchemaManager;
use Doctrine\DBAL\Schema\Column;
use Doctrine\DBAL\Schema\ForeignKeyConstraint;
use Doctrine\DBAL\Schema\Name\UnqualifiedName;
use Doctrine\DBAL\Schema\Schema;
use Doctrine\DBAL\Schema\SchemaConfig;
use Doctrine\DBAL\Schema\Sequence;
use Doctrine\DBAL\Schema\Table;
use Doctrine\DBAL\Types\IntegerType;
use Doctrine\ORM\Configuration as EMConfig;
use Doctrine\ORM\EntityManagerInterface;
use Doctrine\ORM\Mapping\ClassMetadata;
use Doctrine\ORM\Mapping\ClassMetadataFactory;
use Doctrine\ORM\Mapping\QuoteStrategy;
use Doctrine\ORM\Tools\ToolEvents;
use DOMDocument;
use Fabiang\Doctrine\Migrations\Liquibase\Helper\VersionHelper;
use Fabiang\Doctrine\Migrations\Liquibase\Output\LiquibaseOutputInterface;
use PHPUnit\Framework\TestCase;
use Prophecy\Argument;
use Prophecy\PhpUnit\ProphecyTrait;
use Prophecy\Prophecy\ObjectProphecy;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2021-09-14 at 09:59:16.
 *
 * @coversDefaultClass Fabiang\Doctrine\Migrations\Liquibase\LiquibaseSchemaTool
 */
final class LiquibaseSchemaToolTest extends TestCase
{
    use ProphecyTrait;
    use SchemaDiffTrait;
    use TableDiffTrait;

    private LiquibaseSchemaTool $object;
    private ObjectProphecy $em;
    private ObjectProphecy $connection;
    private ObjectProphecy $platform;
    private ObjectProphecy $emConfig;
    private ObjectProphecy $schemaManager;
    private ObjectProphecy $quoteStrategy;
    private ObjectProphecy $eventManager;

    /**
     * Sets up the fixture, for example, opens a network connection.
     * This method is called before a test is executed.
     */
    protected function setUp(): void
    {
        $this->quoteStrategy = $this->prophesize(QuoteStrategy::class);
        $this->eventManager  = $this->prophesize(EventManager::class);
        $this->eventManager->hasListeners(ToolEvents::postGenerateSchemaTable)->willReturn(false);
        $this->eventManager->hasListeners(ToolEvents::postGenerateSchema)->willReturn(false);

        $this->emConfig = $this->prophesize(EMConfig::class);
        $this->emConfig->getSchemaIgnoreClasses()->willReturn([]);
        $this->emConfig->getQuoteStrategy()->willReturn($this->quoteStrategy->reveal());

        $this->schemaManager = $this->prophesize(AbstractSchemaManager::class);

        $this->platform   = $this->prophesize(AbstractPlatform::class);
        $this->connection = $this->prophesize(Connection::class);
        $this->connection->getDatabasePlatform()
            ->willReturn($this->platform->reveal());
        $this->connection->createSchemaManager()
            ->willReturn($this->schemaManager->reveal());

        $this->em = $this->prophesize(EntityManagerInterface::class);
        $this->em->getConnection()->willReturn($this->connection->reveal());
        $this->em->getConfiguration()->willReturn($this->emConfig->reveal());
        $this->em->getEventManager()->willReturn($this->eventManager->reveal());

        $this->object = new LiquibaseSchemaTool($this->em->reveal());
    }

    /**
     * @covers ::diffChangeLog
     * @covers ::sanitizeOutputParameter
     * @covers ::sanitizeMetadatas
     * @covers ::removeLiquibaseTables
     */
    public function testDiffChangeLog(): void
    {
        $dom = new DOMDocument();

        $output = $this->prophesize(LiquibaseOutputInterface::class);
        $output->started(Argument::type(EntityManagerInterface::class));
        $output->terminated();
        $output->getResult()->willReturn($dom);

        $classMetadata1       = $this->prophesize(ClassMetadata::class);
        $classMetadata1->name = 'test1';
        $classMetadata1->getName()->willReturn('test1');
        $classMetadata1->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata1->rootEntityName = 'Foo';

        $classMetadata2       = $this->prophesize(ClassMetadata::class);
        $classMetadata2->name = 'test2';
        $classMetadata2->getName()->willReturn('test2');
        $classMetadata2->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata2->rootEntityName = 'Bar';

        $classMetadataFactory = $this->prophesize(ClassMetadataFactory::class);
        $classMetadataFactory->getAllMetadata()->willReturn([
            $classMetadata1->reveal(),
            $classMetadata2->reveal(),
        ]);

        $schema = $this->prophesize(Schema::class);
        $schema->hasTable('liquibase')->shouldBeCalled()->willReturn(true);
        $schema->hasTable('liquibase_lock')->shouldBeCalled()->willReturn(false);

        $schema->dropTable('liquibase')->shouldBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });
        $schema->dropTable('liquibase_lock')->shouldNotBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });

        $schema->getNamespaces()->willReturn([]);
        $schema->getTables()->willReturn([]);
        $schema->getSequences()->willReturn([]);

        $schemaConfig = $this->prophesize(SchemaConfig::class);

        $this->schemaManager->introspectSchema()->willReturn($schema->reveal());
        $this->schemaManager->createSchemaConfig()->willReturn($schemaConfig->reveal());

        $this->em->getMetadataFactory()->willReturn($classMetadataFactory->reveal());

        $this->assertSame($dom, $this->object->diffChangeLog($output->reveal(), []));
    }

    /**
     * @covers ::diffChangeLog
     * @covers ::sanitizeOutputParameter
     * @covers ::sanitizeMetadatas
     * @covers ::removeLiquibaseTables
     */
    public function testDiffChangeLogMetadataFromFactory(): void
    {
        $dom    = new DOMDocument();
        $output = $this->prophesize(LiquibaseOutputInterface::class);
        $output->started(Argument::type(EntityManagerInterface::class));
        $output->terminated();
        $output->getResult()->willReturn($dom);

        $classMetadata1       = $this->prophesize(ClassMetadata::class);
        $classMetadata1->name = 'test1';
        $classMetadata1->getName()->willReturn('test1');
        $classMetadata1->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata1->rootEntityName = 'Foo';

        $classMetadata2       = $this->prophesize(ClassMetadata::class);
        $classMetadata2->name = 'test2';
        $classMetadata2->getName()->willReturn('test2');
        $classMetadata2->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata2->rootEntityName = 'Bar';

        $classMetadataFactory = $this->prophesize(ClassMetadataFactory::class);
        $classMetadataFactory->getAllMetadata()->willReturn([
            $classMetadata1->reveal(),
            $classMetadata2->reveal(),
        ]);

        $schema = $this->prophesize(Schema::class);
        $schema->hasTable('liquibase')->shouldBeCalled()->willReturn(true);
        $schema->hasTable('liquibase_lock')->shouldBeCalled()->willReturn(false);

        $schema->dropTable('liquibase')->shouldBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });
        $schema->dropTable('liquibase_lock')->shouldNotBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });
        $schema->getNamespaces()->willReturn([]);
        $schema->getTables()->willReturn([]);
        $schema->getSequences()->willReturn([]);

        $schemaConfig = $this->prophesize(SchemaConfig::class);

        $this->schemaManager->introspectSchema()->willReturn($schema->reveal());
        $this->schemaManager->createSchemaConfig()->willReturn($schemaConfig->reveal());

        $this->em->getMetadataFactory()->willReturn($classMetadataFactory->reveal());

        $this->assertSame($dom, $this->object->diffChangeLog($output->reveal(), []));
    }

    /**
     * @covers ::changeLog
     */
    public function testChangeLog(): void
    {
        $dom    = new DOMDocument();
        $output = $this->prophesize(LiquibaseOutputInterface::class);
        $output->started(Argument::type(EntityManagerInterface::class));
        $output->terminated();
        $output->getResult()->willReturn($dom);

        $classMetadata1       = $this->prophesize(ClassMetadata::class);
        $classMetadata1->name = 'test1';
        $classMetadata1->getName()->willReturn('test1');
        $classMetadata1->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata1->rootEntityName = 'Foo';

        $classMetadata2       = $this->prophesize(ClassMetadata::class);
        $classMetadata2->name = 'test2';
        $classMetadata2->getName()->willReturn('test2');
        $classMetadata2->isInheritanceTypeSingleTable()->willReturn(true);
        $classMetadata2->rootEntityName = 'Bar';

        $classMetadataFactory = $this->prophesize(ClassMetadataFactory::class);
        $classMetadataFactory->getAllMetadata()->willReturn([
            $classMetadata1->reveal(),
            $classMetadata2->reveal(),
        ]);

        $schema = $this->prophesize(Schema::class);
        $schema->hasTable('liquibase')->shouldBeCalled()->willReturn(true);
        $schema->hasTable('liquibase_lock')->shouldBeCalled()->willReturn(false);

        $schema->dropTable('liquibase')->shouldBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });
        $schema->dropTable('liquibase_lock')->shouldNotBeCalled()->will(function () use ($schema) {
            return $schema->reveal();
        });
        $schema->getNamespaces()->willReturn([]);
        $schema->getTables()->willReturn([]);
        $schema->getSequences()->willReturn([]);

        $schemaConfig = $this->prophesize(SchemaConfig::class);

        $this->schemaManager->introspectSchema()->willReturn($schema->reveal());
        $this->schemaManager->createSchemaConfig()->willReturn($schemaConfig->reveal());

        $this->em->getMetadataFactory()->willReturn($classMetadataFactory->reveal());

        $this->assertSame($dom, $this->object->diffChangeLog($output->reveal(), []));
    }

    /**
     * @covers ::__construct
     * @covers ::diffChangeLogFromSchemaDiff
     * @covers ::sanitizeOutputParameter
     */
    public function testDiffChangeLogFromSchemaDiff(): void
    {
        $domDocument = new DOMDocument();

        $output = $this->prophesize(LiquibaseOutputInterface::class);

        $output->getResult()
            ->willReturn($domDocument);

        $output->started(Argument::type(EntityManagerInterface::class))->shouldBeCalled();
        $output->terminated()->shouldBeCalled();

        $output->createSchema('newnamespace')->shouldBeCalled();

        $foreignKey1 = $this->prophesize(ForeignKeyConstraint::class);
        $foreignKey1->getName()->willReturn('testfk');
        $foreignKey1->getLocalColumns()->willReturn(['foo']); // Deprecated, but still in use

        if (VersionHelper::isDBALVersion4()) {
            $foreignKey1->getReferencingColumnNames()->willReturn([UnqualifiedName::unquoted('foo')]);
        } else {
            $localTable = $this->prophesize(Table::class);
            $foreignKey1->getLocalTable()->willReturn($localTable->reveal());
            $foreignKey1->setLocalTable(Argument::type(Table::class))->shouldBeCalled();
            $foreignKey1->getColumns()->willReturn(['foo']);
        }

        $foreignKey2 = $this->prophesize(ForeignKeyConstraint::class);
        $foreignKey2->getName()->willReturn('testfk2');

        $table1 = new Table(
            name: 'tablename1',
            columns: [new Column('foo', new IntegerType())],
            fkConstraints: [$foreignKey1->reveal()]
        );
        $table2 = new Table(name: 'tablename2');
        $table3 = new Table(name: 'tablename3');

        $output->dropForeignKey($foreignKey2, Argument::type(Table::class))
            ->shouldBeCalled();

        $sequence1 = $this->prophesize(Sequence::class);
        $sequence2 = $this->prophesize(Sequence::class);
        $sequence3 = $this->prophesize(Sequence::class);

        $output->alterSequence($sequence2)->shouldBeCalled();
        $output->dropSequence($sequence3)->shouldBeCalled();
        $output->createSequence($sequence1)->shouldBeCalled();

        $output->createTable($table1)->shouldBeCalled();
        $output->createForeignKey($foreignKey1, $table1)->shouldBeCalled();

        $output->dropTable($table3)->shouldBeCalled();

        $tableDiff = $this->tableDiff(
            oldTable: $table2,
            addedColumns: [new Column('test', new IntegerType())],
            droppedForeignKeys: [$foreignKey2->reveal()],
        );

        $output->alterTable($tableDiff)->shouldBeCalled();

        $schema = new Schema();

        $schemaDiff = $this->schemaDiff(
            fromSchema: $schema,
            createdSchemas: ['newnamespace'],
            droppedSchemas: ['test'],
            createdTables: [$table1],
            alteredTables: [$tableDiff],
            droppedTables: [$table3],
            createdSequences: [$sequence1->reveal()],
            alteredSequences: [$sequence2->reveal()],
            droppedSequences: [$sequence3->reveal()],
        );

        $result = $this->object->diffChangeLogFromSchemaDiff($schemaDiff, $output->reveal());
        $this->assertSame($domDocument, $result);
    }
}
